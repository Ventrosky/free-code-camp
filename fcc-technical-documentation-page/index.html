<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>FCC: Technical Documentation Page</title>
  <link rel='stylesheet' href='https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css'>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
<div class="grid-container">
   <nav class="sidebar" id ="navbar">
     <header>Learn bash in Y minutes</header>
     <ul> 
      <a class="nav-link" href="#GNU_Bash" rel="internal"><li>GNU Bash</li></a>
	  <a class="nav-link" href="#What_is_a_shell" rel="internal"><li>What is a shell</li></a>
       <a class="nav-link" href="#Variables" rel="internal"><li>Variables</li></a>
       <a class="nav-link" href="#Strings_and_Arrays" rel="internal"><li>Strings and Arrays</li></a>
       <a class="nav-link" href="#Built-in_variables" rel="internal"><li>Built-in variables</li></a>
       <a class="nav-link" href="#Conditionals" rel="internal"><li>Conditionals</li></a>
       <a class="nav-link" href="#Reference" rel="internal"><li>Reference</li></a>
       <a href="javascript:void(0);" class="icon" onclick="myFunction()">
    <i class="fa fa-bars"></i>
  </a>
     </ul>
  </nav>
   <main id="main-doc" class="content">

<section class="main-section" id="GNU_Bash">
<header>GNU Bash</header>
<article>
<p>Bash is a name of the unix shell, which was also distributed as the shell for the GNU operating system and as default shell on Linux and Mac OS X. Nearly all examples below can be a part of a shell script or executed directly in the shell.</p>
<p>
Bash is the Bourne Again Shell. Bash is an sh-compatible shell that incorporates useful features from the Korn shell (ksh) and C shell (csh). It is intended to conform to the IEEE POSIX P1003.2/ISO 9945.2 Shell and Tools standard. It offers functional improvements over sh for both programming and interactive use. In addition, most sh scripts can be run by Bash without modification.
</p>
<p>The improvements offered by Bash include:</p>
<ul>
<li>Command line editing</li>
<li>Unlimited size command history</li>
<li>Job Control</li>
<li>Shell Functions and Aliases</li>
<li>Indexed arrays of unlimited size</li>
<li>Integer arithmetic in any base from two to sixty-four</li>
<li>The maintainer also has a bash page which includes Frequently-Asked-Questions.</li>
</ul>
<p>
Bash can be found on the main GNU ftp server: http://ftp.gnu.org/gnu/bash/ (via HTTP) and ftp://ftp.gnu.org/gnu/bash/ (via FTP). It can also be found on the GNU mirrors; please use a mirror if possible.
 </p>

<pre class="prettyprint">
<code class="language-bash">
#!/usr/bin/env bash
# First line of the script is the shebang which tells the system how to execute
# the script: http://en.wikipedia.org/wiki/Shebang_(Unix)
# As you already figured, comments start with #. Shebang is also a comment.

# Simple hello world example:
echo Hello world! # => Hello world!

# Each command starts on a new line, or after a semicolon:
echo 'This is the first line'; echo 'This is the second line'
# => This is the first line
# => This is the second line
</code>
</pre>
</article>
</section>

<section  class="main-section" id="What_is_a_shell">
     <header class= "header">What is a shell</header>
<article>    
<p>At its base, a shell is simply a macro processor that executes
commands.  The term macro processor means functionality where text
and symbols are expanded to create larger expressions.
</p>
<p>A Unix shell is both a command interpreter and a programming
language.  As a command interpreter, the shell provides the user
interface to the rich set of <small>GNU</small> utilities.  The programming
language features allow these utilities to be combined.
Files containing commands can be created, and become
commands themselves.  These new commands have the same status as
system commands in directories such as <samp>/bin</samp>, allowing users
or groups to establish custom environments to automate their common
tasks.
</p>
<p>Shells may be used interactively or non-interactively.  In
interactive mode, they accept input typed from the keyboard.
When executing non-interactively, shells execute commands read
from a file.
</p>
<p>A shell allows execution of <small>GNU</small> commands, both synchronously and
asynchronously.
The shell waits for synchronous commands to complete before accepting
more input; asynchronous commands continue to execute in parallel
with the shell while it reads and executes additional commands.
The <em>redirection</em> constructs permit
fine-grained control of the input and output of those commands.
Moreover, the shell allows control over the contents of commands&rsquo;
environments.
</p>
<p>Shells also provide a small set of built-in
commands (<em>builtins</em>) implementing functionality impossible
or inconvenient to obtain via separate utilities.
For example, <code>cd</code>, <code>break</code>, <code>continue</code>, and
<code>exec</code> cannot be implemented outside of the shell because
they directly manipulate the shell itself.
The <code>history</code>, <code>getopts</code>, <code>kill</code>, or <code>pwd</code>
builtins, among others, could be implemented in separate utilities,
but they are more convenient to use as builtin commands.
All of the shell builtins are described in
subsequent sections.
</p>
<p>While executing commands is essential, most of the power (and
complexity) of shells is due to their embedded programming
languages.  Like any high-level language, the shell provides
variables, flow control constructs, quoting, and functions. 
</p>
<p>Shells offer features geared specifically for
interactive use rather than to augment the programming language. 
These interactive features include job control, command line
editing, command history and aliases.
</p>
</article>
</section>  
<section class="main-section" id="Variables">
<header>Variables</header>
<article>
<li>Declaring a variables</li>
<pre class="prettyprint">
# Declaring a variable looks like this:
Variable="Some string"

# But not like this:
Variable = "Some string" # => returns error "Variable: command not found"
# Bash will decide that Variable is a command it must execute and give an error
# because it can't be found.

# Nor like this:
Variable= 'Some string' # => returns error: "Some string: command not found"
# Bash will decide that 'Some string' is a command it must execute and give an
# error because it can't be found. (In this case the 'Variable=' part is seen
# as a variable assignment valid only for the scope of the 'Some string'
# command.)
<code class="language-bash">
</code>
</pre>
<li>Using the variables</li>
<pre class="prettyprint">
<code class="language-bash">
# Using the variable:
echo $Variable # => Some string
echo "$Variable" # => Some string
echo '$Variable' # => $Variable
# When you use the variable itself — assign it, export it, or else — you write
# its name without $. If you want to use the variable's value, you should use $.
# Note that ' (single quote) won't expand the variables!
</code>
</pre>
<li>Parameter expansion</li>
<pre class="prettyprint">
<code class="language-bash">
# Parameter expansion ${ }:
echo ${Variable} # => Some string
# This is a simple usage of parameter expansion
# Parameter Expansion gets a value from a variable. 
# It "expands" or prints the value
# During the expansion time the value or parameter can be modified
# Below are other modifications that add onto this expansion
</code>
</pre>
</article>
</section>

<section class="main-section" id="Strings_and_Arrays">
<header>Strings and Arrays</header>
<article>
<li>Strings substitution</li>
<pre class="prettyprint">
<code class="language-bash">
# String substitution in variables
echo ${Variable/Some/A} # => A string
# This will substitute the first occurrence of "Some" with "A"

# Substring from a variable
Length=7
echo ${Variable:0:Length} # => Some st
# This will return only the first 7 characters of the value
echo ${Variable: -5} # => tring
# This will return the last 5 characters (note the space before -5)

# String length
echo ${#Variable} # => 11
</code>
</pre>
<li>Default values</li>
<pre class="prettyprint">
<code class="language-bash">
# Default value for variable
echo ${Foo:-"DefaultValueIfFooIsMissingOrEmpty"} 
# => DefaultValueIfFooIsMissingOrEmpty
# This works for null (Foo=) and empty string (Foo=""); zero (Foo=0) returns 0.
# Note that it only returns default value and doesn't change variable value.
</code>
</pre>
<p>Declare an arrays</p>
<pre class="prettyprint">
<code class="language-bash">
# Declare an array with 6 elements
array0=(one two three four five six)
# Print first element
echo $array0 # => "one"
# Print first element
echo ${array0[0]} # => "one"
# Print all elements
echo ${array0[@]} # => "one two three four five six"
# Print number of elements
echo ${#array0[@]} # => "6"
# Print number of characters in third element
echo ${#array0[2]} # => "5"
# Print 2 elements starting from forth
echo ${array0[@]:3:2} # => "four five"
# Print all elements. Each of them on new line.
for i in "${array0[@]}"; do
    echo "$i"
done
</code>
</pre>
<li>Brace Expansion</li>
<pre class="prettyprint">
<code class="language-bash">
# Brace Expansion { }
# Used to generate arbitrary strings
echo {1..10} # => 1 2 3 4 5 6 7 8 9 10
echo {a..z} # => a b c d e f g h i j k l m n o p q r s t u v w x y z
# This will output the range from the start value to the end value
</code>
</pre>
</article>
</section>

<section class="main-section" id="Built-in_variables">
<header>Built-in variables</header>
<article>
<li>Useful built-in variables</li>
<pre class="prettyprint">
<code class="language-bash">
# There are some useful built-in variables, like
echo "Last program's return value: $?"
echo "Script's PID: $$"
echo "Number of arguments passed to script: $#"
echo "All arguments passed to script: $@"
echo "Script's arguments separated into different variables: $1 $2..."

# Now that we know how to echo and use variables,
# let's learn some of the other basics of bash!

# Our current directory is available through the command `pwd`.
# `pwd` stands for "print working directory".
# We can also use the built-in variable `$PWD`.
# Observe that the following are equivalent:
echo "I'm in $(pwd)" # execs `pwd` and interpolates output
echo "I'm in $PWD" # interpolates the variable
</code>
</pre>
<li>Input Output</li>
<pre class="prettyprint">
<code class="language-bash">
# If you get too much output in your terminal, or from a script, the command
# `clear` clears your screen
clear
# Ctrl-L also works for clearing output

# Reading a value from input:
echo "What's your name?"
read Name # Note that we didn't need to declare a new variable
echo Hello, $Name!
</code>
</pre>
</article>
</section>

<section class="main-section" id="Conditionals">
<header>Conditionals</header>
<article>
<li>If ... Then ... Else</li>
<pre class="prettyprint">
<code class="language-bash">
# We have the usual if structure:
# use `man test` for more info about conditionals
if [ $Name != $USER ]
then
    echo "Your name isn't your username"
else
    echo "Your name is your username"
fi
# True if the value of $Name is not equal to the current user's login username

# NOTE: if $Name is empty, bash sees the above condition as:
if [ != $USER ]
# which is invalid syntax
# so the "safe" way to use potentially empty variables in bash is:
if [ "$Name" != $USER ] ...
# which, when $Name is empty, is seen by bash as:
if [ "" != $USER ] ...
# which works as expected
</code>
</pre>
<li>Conditional execution</li>
<pre class="prettyprint">
<code class="language-bash">
# There is also conditional execution
echo "Always executed" || echo "Only executed if first command fails"
# => Always executed
echo "Always executed" && echo "Only executed if first command does NOT fail"
# => Always executed
# => Only executed if first command does NOT fail


# To use && and || with if statements, you need multiple pairs of square brackets:
if [ "$Name" == "Steve" ] && [ "$Age" -eq 15 ]
then
    echo "This will run if $Name is Steve AND $Age is 15."
fi

if [ "$Name" == "Daniya" ] || [ "$Name" == "Zach" ]
then
    echo "This will run if $Name is Daniya OR Zach."
fi
</code>
</pre>
<li>Regexs</li>
<pre class="prettyprint">
<code class="language-bash">
# There is also the `=~` operator, which tests a string against a Regex pattern:
Email=me@example.com
if [[ "$Email" =~ [a-z]+@[a-z]{2,}\.(com|net|org) ]]
then
    echo "Valid email!"
fi
# Note that =~ only works within double [[ ]] square brackets,
# which are subtly different from single [ ].
# See http://www.gnu.org/software/bash/manual/bashref.html#Conditional-Constructs for more on this.
</code>
</pre>
</article>
</section>

<section class="main-section" id="Reference">
    <header>Reference</header>
    <article>
      <li>All the documentation in this page is taken from <a href="https://learnxinyminutes.com/docs/bash/" target="_blank">Learn X in Y Minutes</a> and <a href="https://www.gnu.org/software/bash/" target="_blank">GNU.org</a></li>
    </article>
    </section>
</main>
</div>
  <script src='https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js'></script>
<script  src="js/index.js"></script>
</body>
</html>